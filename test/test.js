const assert = require("assert");
const BigInt = require("big-integer");

const Ecdsa = require("../ellipticcurve/ecdsa");
const PrivateKey = require("../ellipticcurve/privateKey").PrivateKey;
const PublicKey = require("../ellipticcurve/publicKey").PublicKey;
const Signature = require("../ellipticcurve/signature").Signature;
const File = require("../ellipticcurve/utils/file");


describe("ECDSA test", function() {
    describe("#testVerifyRightMessage()", function() {
        it("should confirm authenticity", function() {
            let privateKey = new PrivateKey();
            let publicKey = privateKey.publicKey();
            let message = "This is the right message";
            let signature = Ecdsa.sign(message, privateKey);

            assert.equal(Ecdsa.verify(message, signature, publicKey), true);
        });
    });
    describe("#testVerifyWrongMessage()", function() {
        it("should deny authenticity", function() {
            let privateKey = new PrivateKey();
            let publicKey = privateKey.publicKey();
            let message1 = "This is the right message";
            let message2 = "This is the wrong message";
            let signature = Ecdsa.sign(message1, privateKey);

            assert.equal(Ecdsa.verify(message2, signature, publicKey), false);
        });
    });
    describe("#testZeroSignature()", function() {
        it("should deny authenticity", function() {
            let privateKey = new PrivateKey();
            let publicKey = privateKey.publicKey();
            let message = "This is the right message";

            assert.equal(Ecdsa.verify(message, new Signature(0, 0), publicKey), false);
        });
    });
});
describe("openSSL test", function() {
    describe("#testAssign()", function() {
        it("should read and verify PEM file", function() {
            // Generated by: openssl ecparam -name secp256k1 -genkey -out privateKey.pem
            let privateKeyPem = File.read("test/privateKey.pem");
            let privateKey = PrivateKey.fromPem(privateKeyPem);
            let message = File.read("test/message.txt");
            let signature = Ecdsa.sign(message, privateKey);
            let publicKey = privateKey.publicKey();

            assert.equal(Ecdsa.verify(message, signature, publicKey), true);
        });
    });
    describe("#testVerifySignature()", function() {
        it("should read and verify signature file", function() {
            // openssl ec -in privateKey.pem -pubout -out publicKey.pem
            let publicKeyPem = File.read("test/publicKey.pem");
            // openssl dgst -sha256 -sign privateKey.pem -out signature.binary message.txt
            let signatureDer = File.read("test/signatureDer.txt", "binary");
            let message = File.read("test/message.txt");
            let publicKey = PublicKey.fromPem(publicKeyPem);
            let signature = Signature.fromDer(signatureDer);

            assert.equal(Ecdsa.verify(message, signature, publicKey), true);
        });
    });
});
describe("PrivateKey test", function() {
    describe("#testPemConversion()", function() {
        it("should validate PEM generation and convertion", function() {
            let privateKey1 = new PrivateKey();
            let pem = privateKey1.toPem();
            let privateKey2 = PrivateKey.fromPem(pem);

            assert.equal(String(privateKey1.secret), String(privateKey2.secret));
            assert.equal(String(privateKey1.curve), String(privateKey2.curve));
        });
    });
    describe("#testDerConversion()", function() {
        it("should validate DER generation and convertion", function() {
            let privateKey1 = new PrivateKey();
            let der = privateKey1.toDer();
            let privateKey2 = PrivateKey.fromDer(der);

            assert.equal(String(privateKey1.secret), String(privateKey2.secret));
            assert.equal(String(privateKey1.curve), String(privateKey2.curve));
        });
    });
    describe("#testStringConversion()", function() {
        it("should validate private-key-string generation and convertion", function() {
            let privateKey1 = new PrivateKey();
            let string = privateKey1.toString();
            let privateKey2 = PrivateKey.fromString(string);

            assert.equal(String(privateKey1.secret), String(privateKey2.secret));
            assert.equal(String(privateKey1.curve), String(privateKey2.curve));
        });
    });
});
describe("PublicKey test", function() {
    describe("#testPemConversion()", function() {
        it("should validate PEM generation and convertion", function() {
            let privateKey = new PrivateKey();
            let publicKey1 = privateKey.publicKey();
            let pem = publicKey1.toPem();
            let publicKey2 = PublicKey.fromPem(pem);

            assert.equal(String(publicKey1.point.x), String(publicKey2.point.x));
            assert.equal(String(publicKey1.point.y), String(publicKey2.point.y));
            assert.equal(publicKey1.curve, publicKey2.curve);
        });
    });
    describe("#testDerConversion()", function() {
        it("should validate DER generation and convertion", function() {
            let privateKey = new PrivateKey();
            let publicKey1 = privateKey.publicKey();
            let der = publicKey1.toDer();
            let publicKey2 = PublicKey.fromDer(der);

            assert.equal(String(publicKey1.point.x), String(publicKey2.point.x));
            assert.equal(String(publicKey1.point.y), String(publicKey2.point.y));
            assert.equal(publicKey1.curve, publicKey2.curve);
        });
    });
    describe("#testStringConversion()", function() {
        it("should validate private-key-string generation and convertion", function() {
            let privateKey = new PrivateKey();
            let publicKey1 = privateKey.publicKey();
            let string = publicKey1.toString();
            let publicKey2 = PublicKey.fromString(string);

            assert.equal(String(publicKey1.point.x), String(publicKey2.point.x));
            assert.equal(String(publicKey1.point.y), String(publicKey2.point.y));
            assert.equal(publicKey1.curve, publicKey2.curve);
        });
    });
});

describe("ComPubKeyTest", function() {
    describe("#testBatch()", function() {
        it("should validate publicKey x and y points", function() {
            this.timeout(10000);
            for (let i = 0; i < 1000; i++) {
                let privateKey = new PrivateKey()
                let publicKey = privateKey.publicKey()
                let publicKeyString = publicKey.toCompressed()
                let recoveredPublicKey = PublicKey.fromCompressed(publicKeyString, publicKey.curve)

                assert.equal(publicKey.point.x.value, recoveredPublicKey.point.x.value)
                assert.equal(publicKey.point.y.value, recoveredPublicKey.point.y.value)
            }
        });
    });
    describe("#testFromCompressedEven()", function() {
        it("should validate publicKey from Even compressed", function() {
            let publicKeyCompressed = "0252972572d465d016d4c501887b8df303eee3ed602c056b1eb09260dfa0da0ab2"
            let publicKey = PublicKey.fromCompressed(publicKeyCompressed)
            let publicKey2 = PublicKey.fromPem("\n-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEUpclctRl0BbUxQGIe43zA+7j7WAsBWse\nsJJg36DaCrKIdC9NyX2e22/ZRrq8AC/fsG8myvEXuUBe15J1dj/bHA==\n-----END PUBLIC KEY-----\n")

            assert.equal(publicKey.toPem(), publicKey2.toPem());
        });
    });
    describe("#testFromCompressedOdd()", function() {
        it("should validate publicKey from Odd compressed", function() {
            let publicKeyCompressed = "0318ed2e1ec629e2d3dae7be1103d4f911c24e0c80e70038f5eb5548245c475f50"
            let publicKey = PublicKey.fromCompressed(publicKeyCompressed)
            let publicKey2 = PublicKey.fromPem("\n-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEGO0uHsYp4tPa574RA9T5EcJODIDnADj1\n61VIJFxHX1BMIg0B4cpBnLG6SzOTthXpndIKpr8HEHj3D9lJAI50EQ==\n-----END PUBLIC KEY-----\n")

            assert.equal(publicKey.toPem(), publicKey2.toPem());
        });
    });
    describe("#testToCompressedEven()", function() {
        it("should validate publicKey to Even compressed", function() {
            let publicKey = PublicKey.fromPem("\n-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEUpclctRl0BbUxQGIe43zA+7j7WAsBWse\nsJJg36DaCrKIdC9NyX2e22/ZRrq8AC/fsG8myvEXuUBe15J1dj/bHA==\n-----END PUBLIC KEY-----\n")
            let publicKeyCompressed = publicKey.toCompressed()

            assert.equal(publicKeyCompressed, "0252972572d465d016d4c501887b8df303eee3ed602c056b1eb09260dfa0da0ab2");
        });
    });
    describe("#testToCompressedOdd()", function() {
        it("should validate publicKey to Odd compressed", function() {
            let publicKey = PublicKey.fromPem("-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEGO0uHsYp4tPa574RA9T5EcJODIDnADj1\n61VIJFxHX1BMIg0B4cpBnLG6SzOTthXpndIKpr8HEHj3D9lJAI50EQ==\n-----END PUBLIC KEY-----")
            let publicKeyCompressed = publicKey.toCompressed()

            assert.equal(publicKeyCompressed, "0318ed2e1ec629e2d3dae7be1103d4f911c24e0c80e70038f5eb5548245c475f50");
        });
    });
});

describe("Signature test", function() {
    describe("#testDerConversion()", function() {
        it("should validate DER signature generation and convertion", function() {
            let privateKey = new PrivateKey();
            let message = "This is a text message";
            let signature1 = Ecdsa.sign(message, privateKey);
            let der = signature1.toDer();
            let signature2 = Signature.fromDer(der);

            assert.equal(String(signature1.r), String(signature2.r));
            assert.equal(String(signature1.s), String(signature2.s));
        });
    });
    describe("#testBase64Conversion()", function() {
        it("should validate Base64 signature generation and convertion", function() {
            let privateKey = new PrivateKey();
            let message = "This is a text message";
            let signature1 = Ecdsa.sign(message, privateKey);
            let base64 = signature1.toBase64();
            let signature2 = Signature.fromBase64(base64);

            assert.equal(String(signature1.r), String(signature2.r));
            assert.equal(String(signature1.s), String(signature2.s));
        });
    });
    describe("#testExternalRandNum()", function () {
        it("should confirm authenticity and same signature", function () {
            let privateKey = new PrivateKey();
            let publicKey = privateKey.publicKey();
            let message = "This is a message";
            let signature_1 = Ecdsa.sign(message, privateKey, null, BigInt(123));
            let signature_2 = Ecdsa.sign(message, privateKey, null, BigInt(123));

            assert.equal(Ecdsa.verify(message, signature_1, publicKey), true);
            assert.equal(Ecdsa.verify(message, signature_2, publicKey), true);
            assert.equal(signature_1.r.value, signature_2.r.value);
            assert.equal(signature_1.s.value, signature_2.s.value);
        });
    });
});
