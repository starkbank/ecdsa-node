const assert = require("assert");
const BigInt = require("big-integer");

const Ecdsa = require("../ellipticcurve/ecdsa");
const PrivateKey = require("../ellipticcurve/privateKey").PrivateKey;
const PublicKey = require("../ellipticcurve/publicKey").PublicKey;
const Signature = require("../ellipticcurve/signature").Signature;
const File = require("../ellipticcurve/utils/file");


describe("ECDSA test", function() {
    describe("#testVerifyRightMessage()", function() {
        it("should confirm authenticity", function() {
            let privateKey = new PrivateKey();
            let publicKey = privateKey.publicKey();
            let message = "This is the right message";
            let signature = Ecdsa.sign(message, privateKey);

            assert.equal(Ecdsa.verify(message, signature, publicKey), true);
        });
    });
    describe("#testVerifyWrongMessage()", function() {
        it("should deny authenticity", function() {
            let privateKey = new PrivateKey();
            let publicKey = privateKey.publicKey();
            let message1 = "This is the right message";
            let message2 = "This is the wrong message";
            let signature = Ecdsa.sign(message1, privateKey);

            assert.equal(Ecdsa.verify(message2, signature, publicKey), false);
        });
    });
    describe("#testZeroSignature()", function() {
        it("should deny authenticity", function() {
            let privateKey = new PrivateKey();
            let publicKey = privateKey.publicKey();
            let message = "This is the right message";

            assert.equal(Ecdsa.verify(message, new Signature(0, 0), publicKey), false);
        });
    });
});
describe("openSSL test", function() {
    describe("#testAssign()", function() {
        it("should read and verify PEM file", function() {
            // Generated by: openssl ecparam -name secp256k1 -genkey -out privateKey.pem
            let privateKeyPem = File.read("test/privateKey.pem");
            let privateKey = PrivateKey.fromPem(privateKeyPem);
            let message = File.read("test/message.txt");
            let signature = Ecdsa.sign(message, privateKey);
            let publicKey = privateKey.publicKey();

            assert.equal(Ecdsa.verify(message, signature, publicKey), true);
        });
    });
    describe("#testVerifySignature()", function() {
        it("should read and verify signature file", function() {
            // openssl ec -in privateKey.pem -pubout -out publicKey.pem
            let publicKeyPem = File.read("test/publicKey.pem");
            // openssl dgst -sha256 -sign privateKey.pem -out signature.binary message.txt
            let signatureDer = File.read("test/signatureDer.txt", "binary");
            let message = File.read("test/message.txt");
            let publicKey = PublicKey.fromPem(publicKeyPem);
            let signature = Signature.fromDer(signatureDer);

            assert.equal(Ecdsa.verify(message, signature, publicKey), true);
        });
    });
});
describe("PrivateKey test", function() {
    describe("#testPemConversion()", function() {
        it("should validate PEM generation and convertion", function() {
            let privateKey1 = new PrivateKey();
            let pem = privateKey1.toPem();
            let privateKey2 = PrivateKey.fromPem(pem);

            assert.equal(String(privateKey1.secret), String(privateKey2.secret));
            assert.equal(String(privateKey1.curve), String(privateKey2.curve));
        });
    });
    describe("#testDerConversion()", function() {
        it("should validate DER generation and convertion", function() {
            let privateKey1 = new PrivateKey();
            let der = privateKey1.toDer();
            let privateKey2 = PrivateKey.fromDer(der);

            assert.equal(String(privateKey1.secret), String(privateKey2.secret));
            assert.equal(String(privateKey1.curve), String(privateKey2.curve));
        });
    });
    describe("#testStringConversion()", function() {
        it("should validate private-key-string generation and convertion", function() {
            let privateKey1 = new PrivateKey();
            let string = privateKey1.toString();
            let privateKey2 = PrivateKey.fromString(string);

            assert.equal(String(privateKey1.secret), String(privateKey2.secret));
            assert.equal(String(privateKey1.curve), String(privateKey2.curve));
        });
    });
});
describe("PublicKey test", function() {
    describe("#testPemConversion()", function() {
        it("should validate PEM generation and convertion", function() {
            let privateKey = new PrivateKey();
            let publicKey1 = privateKey.publicKey();
            let pem = publicKey1.toPem();
            let publicKey2 = PublicKey.fromPem(pem);

            assert.equal(String(publicKey1.point.x), String(publicKey2.point.x));
            assert.equal(String(publicKey1.point.y), String(publicKey2.point.y));
            assert.equal(publicKey1.curve, publicKey2.curve);
        });
    });
    describe("#testDerConversion()", function() {
        it("should validate DER generation and convertion", function() {
            let privateKey = new PrivateKey();
            let publicKey1 = privateKey.publicKey();
            let der = publicKey1.toDer();
            let publicKey2 = PublicKey.fromDer(der);

            assert.equal(String(publicKey1.point.x), String(publicKey2.point.x));
            assert.equal(String(publicKey1.point.y), String(publicKey2.point.y));
            assert.equal(publicKey1.curve, publicKey2.curve);
        });
    });
    describe("#testStringConversion()", function() {
        it("should validate private-key-string generation and convertion", function() {
            let privateKey = new PrivateKey();
            let publicKey1 = privateKey.publicKey();
            let string = publicKey1.toString();
            let publicKey2 = PublicKey.fromString(string);

            assert.equal(String(publicKey1.point.x), String(publicKey2.point.x));
            assert.equal(String(publicKey1.point.y), String(publicKey2.point.y));
            assert.equal(publicKey1.curve, publicKey2.curve);
        });
    });
});
describe("Signature test", function() {
    describe("#testDerConversion()", function() {
        it("should validate DER signature generation and convertion", function() {
            let privateKey = new PrivateKey();
            let message = "This is a text message";
            let signature1 = Ecdsa.sign(message, privateKey);
            let der = signature1.toDer();
            let signature2 = Signature.fromDer(der);

            assert.equal(String(signature1.r), String(signature2.r));
            assert.equal(String(signature1.s), String(signature2.s));
        });
    });
    describe("#testBase64Conversion()", function() {
        it("should validate Base64 signature generation and convertion", function() {
            let privateKey = new PrivateKey();
            let message = "This is a text message";
            let signature1 = Ecdsa.sign(message, privateKey);
            let base64 = signature1.toBase64();
            let signature2 = Signature.fromBase64(base64);

            assert.equal(String(signature1.r), String(signature2.r));
            assert.equal(String(signature1.s), String(signature2.s));
        });
    });
    describe("#testExternalRandNum()", function () {
        it("should confirm authenticity and same signature", function () {
            let privateKey = new PrivateKey();
            let publicKey = privateKey.publicKey();
            let message = "This is a message";
            let signature_1 = Ecdsa.sign(message, privateKey, null, BigInt(123));
            let signature_2 = Ecdsa.sign(message, privateKey, null, BigInt(123));

            assert.equal(Ecdsa.verify(message, signature_1, publicKey), true);
            assert.equal(Ecdsa.verify(message, signature_2, publicKey), true);
            assert.equal(signature_1.r.value, signature_2.r.value);
            assert.equal(signature_1.s.value, signature_2.s.value);
        });
    });
});
